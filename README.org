#+STARTUP: showall indent
#+STARTUP: hidestars
#+PROPERTY: header-args :noweb yes :cache yes :padline yes :tangle no

This post is based on a challenge that [[https://twitter.com/peterseibel][Peter Seibel]] gave our team back in 2013 when I worked at Twitter. He'd been screwing around with Pig and Scalding and was thinking about how some optimizer could rewrite a Pig query to save time on some of the tremendous joins our "customers" were running. Here's the original challenge:

* The Challenge

Write a program whose input is a boolean expression (some combination of ANDs, ORs, NOTs, literal true and false values, and boolean variables) some of whose variables are cheap to access and some of which are expensive to access. (We'll in fact use the simplest cost model: cheap variables are free and expensive variables are infinitely expensive.) The output of this program is a new boolean expression that uses only the cheap variables and which returns true whenever the original would (i.e. for any specific set of values for the variables) and which returns false as often as it can when the original would.

(The motivation for this challenge is things like this: imagine a query that joins data sets and then filters the result. The filter predicate may access variables from both sides of the join but it may be a win to perform a pre-filter on each side of the join first to weed out rows before the join is performed. The pre-filter predicates obviously can only use the variables that are present on one side of the join.)

In slightly more formal terms, given a function f of n variables, the first k < n of which are cheap, you need to produce g such that:

#+BEGIN_EXAMPLE
  f(v1,v2,..vn) = g(v1,v2,...vk) && f(v1,v2,..vn)
#+END_EXAMPLE

Or, to put it another way:

#+BEGIN_EXAMPLE
  !g(v1,v2,...vk) implies !f(v1,v2,...vn)
#+END_EXAMPLE

For purposes of this challenge, you need to write a program that can parse the following grammar:

#+BEGIN_EXAMPLE
  formula     := variable | literal | expression
  variable    := cheap | expensive
  cheap       := v[0-9]+
  expensive   := w[0-9]+
  literal     := "T" | "F"
  expression  := conjunction | disjunction | negation
  conjunction := "(and" ws formula ws formula ")"
  disjunction := "(or" ws formula ws formula ")"
  negation    := "(not" ws formula ")"
  ws          := " "+
#+END_EXAMPLE

Then write a program that takes a file containing expressions in the form, one per line, and output a file containing for each input expression a pre-filter that uses only the cheap variables.

Your entry is disqualified for any of your pre-filters, g:

#+BEGIN_EXAMPLE
  input.exists { x => f(x) != (g(x) && f(x)) } // i.e. must be correct
#+END_EXAMPLE

And correct pre-filters should minimize:

#+BEGIN_EXAMPLE
  input.count { x => !g(x) }
#+END_EXAMPLE

All other things being equal, smaller pre-filters (measured by tree size of the expression) beat bigger ones. Style points are awarded for efficient computation and general cleverness. The grand prize is bragging rights and the satisfaction of a job well done.

* The Solution

Simple enough. I'll start by saying that at the time Peter issued the challenge I had NO idea how to solve a problem like this. How does one rip a boolean expression apart into TWO sub-expressions? In true [[http://www.amazon.com/gp/product/069111966X/ref%3Das_li_tl?ie%3DUTF8&camp%3D1789&creative%3D390957&creativeASIN%3D069111966X&linkCode%3Das2&tag%3Dtheroato201-20&linkId%3D4676I2A4I5RWW7U4][Polya]] style, I deferred that question. The first step was to write a parser. That was easy. Next I'd have to apply boolean transformations like ~(not (not a)) => a~ to try and simplify the original equation, hoping that might kill expensive variables. Beyond that, not sure.

I knew Oscar would be using Scala, and Peter'd code up some Common Lisp monstrosity, so I dusted off Leiningen and got back to the Clojure.

To be extra sexy about it, I wrote the exercise up in an org-mode file. Literate programming, baby. Code Is Data! Documentation Is Code!

Here's the =project.clj= file. For testing I'm using [[https://github.com/clojure/test.check][test.check]], a Clojure port of Haskell's [[https://hackage.haskell.org/package/QuickCheck][QuickCheck]]. This let me run my optimizer on randomly generated boolean expressions and saved me the pain in the ass of trying to construct edge cases. Because I'd been writing a bunch of Scala at the time and couldn't bear to lose my pattern matching, [[https://twitter.com/swannodette][David Nolen's]] [[https://github.com/clojure/core.match][core.match]] makes an appearance as well.

#+BEGIN_SRC clojure :tangle ./project.clj
  (defproject io.samritchie/optimizer "0.1.0-SNAPSHOT"
    :description "Boolean Optimizer in Clojure."
    :url "https://github.com/sritchie/optimizer"
    :license {:name "Eclipse Public License"
              :url "http://www.eclipse.org/legal/epl-v10.html"}
    :dependencies [[org.clojure/core.match "0.3.0-alpha4"]]
    :profiles {:provided
               {:dependencies [[org.clojure/clojure "1.6.0"]]}
               :dev
               {:dependencies [[org.clojure/test.check "0.7.0"]]}})
#+END_SRC

#+BEGIN_SRC clojure :tangle src/optimizer/core.clj :exports none
  (ns optimizer.core
    (:require [clojure.core.match :refer [match]]
              [clojure.set :refer [subset? difference]]))
#+END_SRC

#+BEGIN_SRC clojure :tangle test/optimizer/core_test.clj :exports none
(ns optimizer.core-test
  (:use optimizer.core)
  (:require [clojure.core.match :refer [match]]
            [clojure.test :refer [deftest is]]
            [clojure.test.check :as tc]
            [clojure.test.check.clojure-test :refer [defspec]]
            [clojure.test.check.generators :as gen]
            [clojure.test.check.properties :as prop]))
#+END_SRC

** Parsing

The first step is to parse that grammar. Surprise surprise, Peter's grammar looks like Lisp! This means that we get to use Clojure's reader as our parser, saving us a few lines of code over the solutions those Strongly Typed fellows will have to implement. I used symbols to represent symbols and literals and lists prefixed with the symbols =and=, =or= and =not= to represent the compound expressions.

*** Variables and Literals

Cheap variables start with =v=, expensive variables start with =w=.

#+BEGIN_SRC clojure :tangle src/optimizer/core.clj
   (def prefixes
     "The set of valid variable prefixes."
     #{\v \w})

   (def prefix
     "Returns the supplied symbol's first character."
     (comp first name))

  (defn cheap
    "Generates a cheap variable using the supplied number."
    [n]
    (symbol (str \v n)))

  (defn expensive
    "Generates an expensive variable using the supplied number."
    [n]
    (symbol (str \w n)))
#+END_SRC

=true= and =false= are both represented as literals:

#+BEGIN_SRC clojure :tangle src/optimizer/core.clj
  (def literals #{'T 'F})
#+END_SRC

Let's round out variables and literals with a couple of validators, since we don't have a type system to help us out:

#+BEGIN_SRC clojure :tangle src/optimizer/core.clj
  (defn variable?
    "Returns true if the argument is a valid cheap or expensive
    variable, false otherwise."
    [x]
    (and (symbol? x)
         (contains? prefixes (prefix x))))

  (def literal?
    "Returns true if passed a literal, false otherwise."
    (comp boolean literals))
#+END_SRC

*** Compound Expressions

A formula is a variable, a literal or an expression. Let's implement expression parsing. Conjunctions and disjunctions, or =AND=s and =OR=s, are both binary expressions. negation, or =NOT=, is unary. These validators help us distinguish those cases and peel apart lists:

#+BEGIN_SRC clojure :tangle src/optimizer/core.clj
  (defn unary? [exp]
    (and (coll? exp)
         (= 2 (count exp))))

  (defn binary? [exp]
    (and (coll? exp)
         (= 3 (count exp))))

  (def func
    "Returns the function of the supplied boolean expression."
    first)

  (def args
    "Returns the arguments of the supplied boolean expression."
    rest)
#+END_SRC

Next, some functions to build and validate the various compound expressions. Conjunctions are lists of the form ~(and <arg1> <arg2>)~:

#+BEGIN_SRC clojure :tangle src/optimizer/core.clj
  (defn AND?
    "Returns true if the supplied expression is of the form
    (and <variable> <variable>), false otherwise."
    [exp]
    (and (binary? exp)
         (= 'and (func exp))))

  (defn AND [a b] (list 'and a b))
#+END_SRC

Similarly, disjunctions are lists of the form ~(or <arg1> <arg2>)~:

#+BEGIN_SRC clojure :tangle src/optimizer/core.clj
  (defn OR?
    "Returns true if the supplied expression is of the form
    (or <variable> <variable>), false otherwise."
    [exp]
    (and (binary? exp)
         (= 'or (func exp))))

  (defn OR [a b] (list 'or a b))
#+END_SRC

And negations are one-arg lists starting with the ~not~ symbol:

#+BEGIN_SRC clojure :tangle src/optimizer/core.clj
  (defn NOT?
    "Returns true if the supplied expression is of the form
    (not <variable>), false otherwise."
    [exp]
    (and (unary? exp)
         (= 'not (func exp))))

  (defn NOT
    "If x is a negation, returns its argument, else returns the negation
    of x."
    [x]
    (if (NOT? x)
      (first (args x))
      (list 'not x)))
#+END_SRC

The =NOT= constructor gets ahead of the game a little by implementing a simplification using the involution law:

#+BEGIN_EXAMPLE
(NOT (NOT p)) => p
#+END_EXAMPLE

If =NOT= is passed a form that's already a negation, it plucks that argument out rather than wrapping it up in a further negation.

Finally, a compound validator for expressions:

#+BEGIN_SRC clojure :tangle src/optimizer/core.clj
  (def expr?
    "Returns true if the supplied expression is a valid boolean
    expression, false otherwise."
    (some-fn AND? OR? NOT?))
#+END_SRC

** Splitting the Expression

The original challenge was to pull a boolean expression out into two expressions, such that

#+BEGIN_EXAMPLE
  f(v1,v2,..vn) = g(v1,v2,...vk) && f(v1,v2,..vn)
#+END_EXAMPLE

This restriction made a lot more sense here in 2015 now that I've heard of "[[http://en.wikipedia.org/wiki/Conjunctive_normal_form][Conjunctive Normal Form]]", or CNF.

*** Conjunctive Normal Form

A CNF expression =AND=s together a bunch of "clauses"; a clause can be a disjunction or a negation (an =OR= or a =NOT=), a literal or a variable. Clauses can nest inside each other, but =AND=s only exist at the top level.

Here are some examples from the [[http://en.wikipedia.org/wiki/Conjunctive_normal_form][wiki page]]:

#+BEGIN_SRC clojure
  (and (not a) (or b c))
  (and (and (or a b)
            (or (or (not b) c)
                (not d)))
       (or d (not e)))
  (and a b)

  ;; Because there's only one clause, this is like (and T (or a b))
  (or a b)
#+END_SRC

These expressions break the CNF rules:

#+BEGIN_SRC clojure
  (not (and b c)) ;; top level negation
  (or c (and a b)) ;; and inside or
#+END_SRC

Every boolean expression can be converted to CNF through the mechanical transformations we'll implement below. [[http://www.cs.jhu.edu/~jason/tutorials/convert-to-CNF.html][This page]] does a nice job of describing the algorithm.

*** Simplifying

Along the way to CNF the optimizer will also try to simplify the incoming boolean expressions. If some simplification kills an expensive variable, great!

There are a few boolean simplification laws (see [[http://www.nayuki.io/page/boolean-algebra-laws][this page]] for a nice summary) that will lead toward CNF and potentially kill terms.

- Involution Law:  ~(not (not a)) == a~
- Identity Laws:   ~(and a F) == F~, ~(and a T) == a~, ~(or a F) == a~, ~(or a T) == T~
- Idempotent Laws: ~(or a a) == a~, ~(and a a) == a~
- Complement Laws: ~(and a (not a) == F~, ~(or a (not a)) == T~,
                   ~(not F) == T~, ~(not T) == F~
- Annihilation:    ~(or a T) == T~, ~(and a F) == F~
- Absorption Law:  ~(and p (or p q)) == p~, ~(or p (and p q) == p~

We'll also want to apply [[http://en.wikipedia.org/wiki/De_Morgan%2527s_laws][DeMorgan's Law]] in one direction to move negations deeper into the expression:

- ~(not (and p q)) == (or (not p) (not q))~
- ~(not (or p q))  == (and (not p) (not q))~

The =simplify= function we want will take a valid boolean expression and return a valid boolean expression. Here's a first try, using [[https://github.com/clojure/core.match][core.match]]'s pattern matching to destructure our boolean expressions. Take a look at the whole thing before we break it down.

#+NAME: simplify
#+BEGIN_SRC clojure
  (defn simplify
    "returns a simplified expression in Conjunctive Normal
    Form."
    [exp]
    (match (if (expr? exp) (vec exp) exp)
           ;; AND and OR simplification
           <<binary-simple>>

           ;; NOT complement laws:
           <<not-simple>>

           ;; (NOT (NOT p)) => p (involution law)
           <<involution>>

           ;; DeMorgan's Laws
           <<demorgan>>

           <<simplify-negation>>

           ;; Returns constants and literals.
           :else exp))
#+END_SRC

Make sense? If the argument's a valid expression via ~(expr? expr)~, turn it into a vector to make pattern matching look cleaner. Otherwise leave it alone.

If we have a conjunction or disjunction, we'll use the helper functions =simplify-and= and =simplify-or= to apply the simplification laws from above to the recursively-simplified expression arguments. (If you don't know how to code something, functional programming is brilliant at letting you kick the problem down the road into another function.)

#+NAME: binary-simple
#+BEGIN_SRC clojure
  ['and p q] (simplify-and (simplify p) (simplify q))
  ['or  p q] (simplify-or  (simplify p) (simplify q))
#+END_SRC

If the expression is a negation, we can apply a few laws directly inside the pattern match. Negating a literal gives back a literal:

#+NAME: not-simple
#+BEGIN_SRC clojure
    ['not 'T] 'F
    ['not 'F] 'T
#+END_SRC

If the negation has another negation inside of it, we can un-nest the =p= of =(not (not p))= and recursively simplify it. (Note that core.match needs that internal =(,,, :seq)= wrapper to match a list).

#+NAME: involution
#+BEGIN_SRC clojure
  ['not (['not p] :seq)] (simplify p)
#+END_SRC

Otherwise we just simplify the argument and return the negation of that:

#+NAME: simplify-negation
#+BEGIN_SRC clojure
  ['not x] (NOT (simplify x))
#+END_SRC

DeMorgan's laws are easy to match as well. If we see ~(not (and p q))~ or ~(not (or p q))~, we apply the law and simplify the resulting form.

#+NAME: demorgan
#+BEGIN_SRC clojure
  ['not (['and p q] :seq)] (simplify (OR (NOT p) (NOT q)))
  ['not (['or p q] :seq)] (simplify (AND (NOT p) (NOT q)))
#+END_SRC

The =:else= clause bounces literals and variables back out without any transformation.

Now we have to write =simplify-and= and =simplify-or=.

*** Flattening

After thinking about this for a while, it became clear that simplifying binary expressions was a major pain in the ass. Take annihilation:

#+BEGIN_EXAMPLE
(and a (not a)) => F
#+END_EXAMPLE

It's really hard to find this pattern with deep nesting of =AND= expressions:

#+BEGIN_SRC clojure
(and (and a b) (and c (not a)))
#+END_SRC

It's much easier to deal with the simplification laws with some way of flattening out those binary expressions. We need a way of transforming the above expression into

#+BEGIN_SRC clojure
(and a b c (not a))
#+END_SRC

Then it becomes easy to perform operations on the set of all conjunctions. Because we'll need to flatten =AND= and =OR= trees, I wrote a =flatten-binary= function that takes a predicate to see if some expression can be flattened. I can't express it without a type system, but pred has to be =AND?= or =OR?= from above.

#+BEGIN_SRC clojure :tangle src/optimizer/core.clj
  (defn flatten-binary
    "Returns a function that takes a binary expression and flattens it
    down into a variadic version. Returns the arguments to the variadic
    version.

    If the initial expression doesn't pass the checker, returns a
    singleton list with only that element."
    [pred]
    (fn flatten* [e]
      (if-not (pred e)
        [e]
        (mapcat (fn [x]
                  (if (pred x)
                    (flatten* x)
                    [x]))
                (rest e)))))
#+END_SRC

The returned function takes an expression. If that expression does NOT pass the predicate - say the predicate is =AND?= and you pass in =(or a b)= - it returns a singleton list with that argument.

If it does pass the predicate, every argument to the expression gets flattened recursively using that same predicate and concatenated together. Now we can make specific versions for =AND?= and =OR?=:

#+BEGIN_SRC clojure :tangle src/optimizer/core.clj
  (def flatten-and (flatten-binary AND?))
  (def flatten-or (flatten-binary OR?))
#+END_SRC

Flattening is great for simplification, but to stick to the grammar we'll need to convert a flattened expression back into a nested form. The beatifully-named =op->binary= does this by folding all the expression arguments together using =AND= or =OR=. If the argument list is empty, you get the literal ='T= back out.

#+BEGIN_SRC clojure :tangle src/optimizer/core.clj
  (defn op->binary
    "Moves the `op` instances back into binary form. If no ops are
    provided, returns 'T."
    [op]
    (fn [[x & xs]]
      (reduce op (or x 'T) xs)))
#+END_SRC

Specialized versions, like before:

#+BEGIN_SRC clojure :tangle src/optimizer/core.clj
  (def and->binary (op->binary AND))
  (def or->binary (op->binary OR))
#+END_SRC

*** Absorption Law

Next we model the absorption law. This is why we needed to flatten stuff; so we can look for cases of this.

#+NAME: absorption-law
#+BEGIN_SRC clojure
  (defn combinations
    "Thanks to amalloy: https://gist.github.com/amalloy/1042047"
    [n coll]
    (if (= 1 n)
      (map list coll)
      (lazy-seq
       (when-let [[head & tail] (seq coll)]
         (concat (for [x (combinations (dec n) tail)]
                   (cons head x))
                 (combinations n tail))))))

  (defn absorption-law
    "let lawHandled = case `flatten-fn` of
     `flatten-or`  -> p AND (p OR q) == p
     `flatten-and` -> p OR (p AND q) == p

    Absorption law, from: http://www.nayuki.io/page/boolean-algebra-laws

    The input exprs must all be conjunctions if you pass `flatten-or`
    and all disjunctions if you pass `flatten-and`.

    Returns a sequence of simplified conjunctions (or disjunctions)."
    [flatten-fn exprs]
    (let [exprs (set exprs)
          args* (comp set flatten-fn)]
      (->> (for [[l r] (combinations 2 exprs)
                 :let [ls (args* l)
                       rs (args* r)]]
             (cond (subset? ls rs) #{r}
                   (subset? rs ls) #{l}
                   :else #{}))
           (reduce into #{})
           (difference exprs)
           (seq))))
#+END_SRC

*** Final Simplifications

Finally we can handle the other binary expression simplifications we haven't deal with yet. Thing thing can take binary arguments OR an entire flattened list. Makes it easier to call below.

#+NAME: simplify-binary
#+BEGIN_SRC clojure
  (defn simplify-binary
    "Returns a function that simplifies binary expressions.

    Rules handled:

    Annihilator: (p OR T) = T, (p AND F) = F
    Identity:    (p AND T) = p, (p OR F) = p
    Idempotence: (p AND p) = (p OR p) = p (accumulating into a set)
    Complement:  (p AND (NOT p)) = F, (p OR (NOT p)) = T

    The flattening implementation depends on associativity and
    commutativity."
    [{:keys [ctor annihilator id flatten-fn tear-fn]}]
    (let [zip-fn (op->binary ctor)]
      (fn attack
        ([l r] (attack (flatten-fn (ctor l r))))
        ([xs]
         (letfn [(absorb [acc p]
                   (cond (= p id) acc
                         (or (= p annihilator)
                             (acc (NOT p)))
                         (reduced [annihilator])
                         :else (conj acc p)))]
           (->> (reduce absorb #{} xs)
                (absorption-law tear-fn)
                (zip-fn)))))))
#+END_SRC

To make a conjunction simplifier we configure =simplify-binary=:

#+NAME: simplify-and
#+BEGIN_SRC clojure
  (def simplify-and
    "Returns a function that simplifies an AND expression. Returns an
    expression in conjunctive normal form."
    (simplify-binary
     {:ctor AND
      :annihilator 'F
      :id 'T
      :flatten-fn flatten-and
      :tear-fn flatten-or}))
#+END_SRC

Or's a little harder, since we have to use the distributive law to turn the =OR= into an =AND=.

#+NAME: simplify-or
#+BEGIN_SRC clojure
  (def simplify-or*
    "Returns a function that simplifies an OR expression."
    (simplify-binary
     {:ctor OR
      :id 'F
      :annihilator 'T
      :flatten-fn flatten-or
      :tear-fn flatten-and}))

  (defn simplify-or
    "Applies the distributive law to convert the OR into CNF, then
    applies the AND simplifications."
    [l r]
    (simplify-and
     (for [l (flatten-and l)
           r (flatten-and r)]
       (simplify-or* l r))))
#+END_SRC

#+BEGIN_SRC clojure :tangle src/optimizer/core.clj :exports none
<<absorption-law>>
<<simplify-binary>>
<<simplify-and>>
<<simplify-or>>

;; Finally, someting work
<<simplify>>
#+END_SRC

*** Killing expensive variables

To solve the puzzle, We need to flatten all the conjunctions out and kill any conjunction that has expensive variables. First step is to write a checker that can see if a subexpression only have cheap variables.

#+BEGIN_SRC clojure :tangle src/optimizer/core.clj
  (defn make-checker
    "Takes a predicate that checks the leaves."
    ([pred] (make-checker pred (fn [_] false)))
    ([pred else]
     (fn recurse [exp]
       (boolean
        (cond (or (pred exp) (literal? exp)) true
              (expr? exp) (every? recurse (args exp))
              :else (else exp))))))

  (def cheap?
    "Returns true if the supplied expression contains only cheap
    variables, false otherwise."
    (make-checker
     (fn [x]
       (if (variable? x)
         (= \v (prefix x))))))

  (def expensive?
    "Returns true if the supplied expression is fully expensive, false
    otherwise."
    (complement cheap?))
#+END_SRC

Finally, the solution:

#+BEGIN_SRC clojure :tangle src/optimizer/core.clj
  (defn pushdown-only [exp]
    (and->binary
     (filter cheap? (flatten-and (simplify exp)))))
#+END_SRC

*** Factoring

Factoring reverses out that explosion we got, tearing the ORs out to get into CNF.

#+BEGIN_SRC clojure :tangle src/optimizer/core.clj
  (def separate (juxt filter remove))

  (defn factor
    "Reverse of the distributive property:

    (and (p or q) (p or z)) = (p or (and q z))"
    [cnf-exp]
    (letfn [(max-factor [ors]
              (->> (apply concat ors)
                   (frequencies)
                   (sort-by (comp - val))
                   (first)))
            (factor* [clauses]
              (let [flat-clauses (map flatten-or clauses)
                    [shared-exp n] (max-factor flat-clauses)]
                (and->binary
                 (if (= n 1)
                   clauses
                   (let [factorable? (partial some #{shared-exp})
                         [haves have-nots] (separate factorable? flat-clauses)
                         conjuncts (for [clause haves :when (not= clause [shared-exp])]
                                     (or->binary (remove #{shared-exp} clause)))]
                     ;; If you can't pull the shared expression out of 2
                     ;; or more subexpressions, abort.
                     (if (< (count conjuncts) 2)
                       clauses
                       (let [factored (OR shared-exp (factor* conjuncts))]
                         (if-let [remaining (not-empty (map or->binary have-nots))]
                           [(factor* remaining) factored]
                           [factored]))))))))]
      (factor*
       (flatten-and cnf-exp))))

  (def pushdown
    (comp factor pushdown-only))
#+END_SRC

** Tests

Now let's get to the tests! Here are the variable generators

#+BEGIN_SRC clojure :tangle test/optimizer/core_test.clj
  (def cheap-v (gen/fmap cheap gen/nat))
  (def expensive-v (gen/fmap expensive gen/nat))
  (def variable (gen/one-of [cheap-v expensive-v]))
#+END_SRC

Big bad recursive generators:

#+BEGIN_SRC clojure :tangle test/optimizer/core_test.clj
  (defn tuplefn [g]
    (letfn [(apply-tuple [[op & xs]] (apply op xs))]
      (gen/fmap apply-tuple g)))

  (defn nested-binary [f]
    (-> (fn [g]
          (tuplefn
           (gen/tuple (gen/return f) g g)))
        (gen/recursive-gen variable)))
#+END_SRC

Flatten and re-binary tests:

#+BEGIN_SRC clojure :tangle test/optimizer/core_test.clj
  ;; Make sure that flatten-and kills all the nested ands.
  (defspec flatten-and-spec
    100
    (prop/for-all
     [e (nested-binary AND)]
     (let [flattened (flatten-and e)]
       (and (AND? e)
            (every? variable? flattened)))))

  ;; Same thing for or:
  (defspec flatten-or-spec
    100
    (prop/for-all
     [e (nested-binary OR)]
     (let [flattened (flatten-or e)]
       (and (OR? e) (every? variable? flattened)))))

  ;; Also check that and->binary reverses flatten-and.
  (defspec and->binary-spec
    100
    (prop/for-all
     [e (nested-binary AND)]
     (let [flattened (flatten-and e)]
       (= flattened (flatten-and (and->binary flattened))))))

  ;; And the same thing for or:
  (defspec or->binary-spec
    100
    (prop/for-all
     [e (nested-binary OR)]
     (let [flattened (flatten-or e)]
       (= flattened (flatten-or (or->binary flattened))))))
#+END_SRC

Expression generator:

#+BEGIN_SRC clojure :tangle test/optimizer/core_test.clj
  (def compound
    (fn [g]
      (tuplefn
       (gen/one-of
        [(gen/tuple (gen/elements [AND OR]) g g)
         (gen/tuple (gen/return NOT) g)]))))

  (def expr
    "test.check generator for expressions."
    (gen/recursive-gen compound variable))
#+END_SRC

#+BEGIN_SRC clojure :tangle test/optimizer/core_test.clj
  (defn variables
    "Returns a set of all unique variables in the supplied expression."
    [e]
    (let [e (if (expr? e) (flatten e) [e])]
      (set (filter variable? e))))

  (defn sized-expr
    "Takes some limit on the size of the number of variables in the
    generated expression and returns a generator that won't break that
    number."
    [variable-limit]
    (gen/such-that #(< (count (variables %))
                       variable-limit)
                   expr))

  ;; ### Solver

  (defn solve
    "Takes an expression and a map of variables -> boolean value."
    [e m]
    (letfn [(solve* [e]
              (match (if (expr? e) (vec e) e)
                     'T true
                     'F false
                     ['and p q] (and (solve* p) (solve* q))
                     ['or p q] (or (solve* p) (solve* q))
                     ['not p] (not (solve* p))
                     :else (m e)))]
      (solve* e)))

  ;; Brute force checks of the simplifier.

  (defn cartesian-prod
    "Generates the cartesian product of all the input sequences."
    [colls]
    (if (empty? colls)
      '(())
      (for [x (first colls)
            more (cartesian-prod (rest colls))]
        (cons x more))))

  (defn variable-map
    "Returns a sequence of maps of variable -> Boolean assignment. The
    returned number of maps is equal to 2^n, where n is the number of
    variables."
    [vs]
    (let [vs (vec vs)
          c  (count vs)]
      (map (partial zipmap vs)
           (cartesian-prod
            (repeat c [true false])))))

  (defn expr-variables
    "Returns a sequence of maps of the variables that appear in any of
    the exprs -> boolean combinations."
    [& exprs]
    (variable-map (mapcat variables exprs)))

  (defn equal?
    "Are the two expressions equal for every possible input?"
    [e1 e2]
    (every? (fn [m]
              (= (solve e1 m)
                 (solve e2 m)))
            (expr-variables e1 e2)))

  ;; Simplifiyng an expression yields an expression equal to the
  ;; original expression.
  (defspec simplify-spec
    100
    (prop/for-all
     [e (sized-expr 7)]
     (let [s (simplify e)]
       (equal? e s))))
#+END_SRC

Factoring tests. Simplifying then factoring shouldn't mess with the equality of the boolean expressions.


#+BEGIN_SRC clojure :tangle test/optimizer/core_test.clj
  (defspec factor-spec
    100
    (prop/for-all
     [e (sized-expr 7)]
     (let [s (simplify e)
           f (factor s)]
       (equal? s f))))

  ;; pushing
  (defspec cheap-spec
    100
    (prop/for-all
     [e (gen/such-that expensive? expr)]
     (let [p (pushdown-only e)
           f (factor p)]
       (and (cheap? p)
            (cheap? f)))))
#+END_SRC

And the final law! The simplified function returns true whenever the original would, and false as often as it can.

#+BEGIN_SRC clojure :tangle test/optimizer/core_test.clj
  (defspec prefilter-correctness-law
    100
    (prop/for-all
     [e (sized-expr 8)]
     (let [simplified (pushdown e)]
       (every? (fn [m]
                 ;; !simplified => !e
                 ;; !(!simplified) OR !e
                 ;; simplified OR !e
                 (or (solve simplified m)
                     (not (solve e m))))
               (expr-variables e simplified)))))
#+END_SRC

CNF tests:

#+BEGIN_SRC clojure :tangle test/optimizer/core_test.clj
  ;; ## CNF Checks

  (defn cnf-literal? [p]
    (boolean
     (or (variable? p)
         (literal? p)
         (if (NOT? p)
           (cnf-literal?
            (second p))))))

  (defn cnf-clause? [p]
    (or (cnf-literal? p)
        (and (OR? p) (every? cnf-clause? (args p)))))

  (defn cnf? [p]
    (or (cnf-literal? p)
        (cnf-clause? p)
        (and (AND? p) (every? cnf-clause? (flatten-and p)))))

  (defspec cnf-spec
    100
    (prop/for-all [e expr]
                  (cnf? (simplify e))))
#+END_SRC

Some extra remaining tests:

#+BEGIN_SRC clojure :tangle test/optimizer/core_test.clj
  (def valid?
    "Returns true if the supplied expression is a valid boolean
    expression, false otherwise. The test is applied recursively down to
    all subforms."
    (make-checker
     variable?
     #(println "Subexpression is invalid: " %)))

  (deftest needs-name-test
    (let [mixed-exp '(and (or w1 v1) v2)]
      (is (= mixed-exp
             (AND (OR (expensive 1)
                      (cheap 1))
                  (cheap 2))))
      (is (not (cheap? mixed-exp)))
      (is (valid? mixed-exp))))

  (deftest simplify-tests
    (let [example-expression '(or (and (and v1 (or v2 v3)) (not w1)) F)]
      "Reduce away the or F:"
      (is (equal? example-expression (simplify example-expression)))

      "and F == F"
      (is (equal? 'F '(and (and (and v1 (or v2 v3)) (not w1)) F)))

      "No reduction..."
      (is (equal? '(and (or w1 v1) v2)
                  (simplify '(and (or w1 v1) v2))))

      "(or a a) => a"
      (is (equal? '(and w1 v2)
                  (simplify '(and (or w1 w1) v2))))))
#+END_SRC

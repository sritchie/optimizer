#+STARTUP: showall indent
#+STARTUP: hidestars
#+PROPERTY: padline no
#+PROPERTY: mkdirp yes
#+PROPERTY: exports code
#+PROPERTY: results replace
#+PROPERTY: cache yes
#+PROPERTY: eval no-export

* The Challenge

Write a program whose input is a boolean expression (some combination of ANDs, ORs, NOTs, literal true and false values, and boolean variables) some of whose variables are cheap to access and some of which are expensive to access. (We'll in fact use the simplest cost model: cheap variables are free and expensive variables are infinitely expensive.) The output of this program is a new boolean expression that uses only the cheap variables and which returns true whenever the original would (i.e. for any specific set of values for the variables) and which returns false as often as it can when the original would.

(The motivation for this challenge is things like this: imagine a query that joins data sets and then filters the result. The filter predicate may access variables from both sides of the join but it may be a win to perform a pre-filter on each side of the join first to weed out rows before the join is performed. The pre-filter predicates obviously can only use the variables that are present on one side of the join.)

In slightly more formal terms, given a function f of n variables, the first k < n of which are cheap, you need to produce g such that:

#+BEGIN_EXAMPLE
  f(v1,v2,..vn) = g(v1,v2,...vk) && f(v1,v2,..vn)
#+END_EXAMPLE

Or, to put it another way:

#+BEGIN_EXAMPLE
  !g(v1,v2,...vk) implies !f(v1,v2,...vn)
#+END_EXAMPLE

For purposes of this challenge, you need to write a program that can parse the following grammar:

#+BEGIN_EXAMPLE
  formula     := variable | literal | expression
  variable    := cheap | expensive
  cheap       := v[0-9]+
  expensive   := w[0-9]+
  literal     := "T" | "F"
  expression  := conjunction | disjunction | negation
  conjunction := "(and" ws formula ws formula ")"
  disjunction := "(or" ws formula ws formula ")"
  negation    := "(not" ws formula ")"
  ws          := " "+
#+END_EXAMPLE

Then write a program that takes a file containing expressions in the form, one per line, and output a file containing for each input expression a pre-filter that uses only the cheap variables.

Your entry is disqualified for any of your pre-filters, g:

#+BEGIN_EXAMPLE
  input.exists { x => f(x) != (g(x) && f(x)) } // i.e. must be correct
#+END_EXAMPLE


And correct pre-filters should minimize:

#+BEGIN_EXAMPLE
  input.count { x => !g(x) }
#+END_EXAMPLE

All other things being equal, smaller pre-filters (measured by tree size of the expression) beat bigger ones. Style points are awarded for efficient computation and general cleverness. The grand prize is bragging rights and the satisfaction of a job well done.

* The Code

Project file:

#+BEGIN_SRC clojure :tangle ./project.clj
(defproject optimizer "0.1.0-SNAPSHOT"
  :description "FIXME: write description"
  :url "http://example.com/FIXME"
  :license {:name "Eclipse Public License"
            :url "http://www.eclipse.org/legal/epl-v10.html"}
  :dependencies [[org.clojure/clojure "1.5.1"]
                 [org.clojure/core.match "0.2.0-rc5"]]
  :profiles {:dev {:resource-paths ["dev"]
                   :dependencies [[midje "1.5.1"]]
                   :plugins [[lein-midje "3.0.0"]]}})
#+END_SRC

Namespace declaration, pulling in =core.match= and =midje= for inline tests.

#+BEGIN_SRC clojure :tangle src/optimizer/core.clj
  (ns optimizer.core
    (:refer-clojure :exclude (complement))
    (:use midje.sweet)
    (:require [clojure.core.match :as m :refer (match)]))
#+END_SRC

 Okay, let's get our grammar worked out. We're parsing expressions that look like standard lisp forms: ~(and (or v0 v1) v2)~, so the reader itself will do for a parser.

#+BEGIN_SRC clojure :tangle src/optimizer/core.clj
  (def prefixes
    "The set of valid variable prefixes."
    #{\v \w})

  (def prefix
    "Returns the supplied symbol's first character."
    (comp first name))

  ;; Variable validation

  (def literals #{'T 'F})
  (def literal? (comp boolean literals))

  (defn variable? [x]
    (and (symbol? x)
         (contains? prefixes (prefix x))))

  (defn cheap? [x]
    (and (variable? x) (= \v (prefix x))))

  (defn expensive? [x]
    (and (variable? x) (= \w (prefix x))))

  ;; Variable Creation

  (defn cheap [n]
    (symbol (str \v n)))

  (defn expensive [n]
    (symbol (str \w n)))

  ;; Expression Validation

  (defn unary? [exp]
    (and (coll? exp)
         (= 2 (count exp))))

  (defn binary? [exp]
    (and (coll? exp)
         (= 3 (count exp))))

  (defn func
    "Returns the function of the supplied boolean expression."
    [exp] (first exp))

  (defn arguments
    "Returns the arguments of the supplied boolean expression."
    [exp] (rest exp))

  (defn conjunction?
    "Returns true if the supplied expression is of the form
    (and <variable> <variable>), false otherwise."
    [exp]
    (and (binary? exp)
         (= 'and (func exp))))

  (defn conjunction [a b] (list 'and a b))

  (defn disjunction?
    "Returns true if the supplied expression is of the form
    (or <variable> <variable>), false otherwise."
    [exp]
    (and (binary? exp)
         (= 'or (func exp))))

  (defn disjunction [a b] (list 'or a b))

  (defn negation?
    "Returns true if the supplied expression is of the form
    (not <variable>), false otherwise."
    [exp]
    (and (unary? exp)
         (= 'not (func exp))))

  (defn negation [x] (list 'not x))

  (defn complement
    "If x is a negation, returns its argument, else returns the negation
    of x."
    [x]
    (if (negation? x)
      (first (arguments x))
      (negation x)))

  (def expression?
    "Returns true if the supplied expression is a valid boolean
    expression, false otherwise."
    (some-fn conjunction? disjunction? negation?))

#+END_SRC

Next, I built a couple of checkers. =valid?= checks that the tree is a valid expression in our grammar. =fully-cheap?= checks that some subtree contains only valid subexpressions, literals and cheap variables.

#+BEGIN_SRC clojure :tangle src/optimizer/core.clj

  (defn make-checker
    ([pred] (make-checker pred (fn [_] false)))
    ([pred else]
       (fn recurse [exp]
         (boolean
          (cond (or (pred exp) (literal? exp)) true
                (expression? exp) (every? recurse (arguments exp))
                :else (else exp))))))

  (def valid?
    "Returns true if the supplied expression is a valid boolean
    expression, false otherwise. The test is applie recursively down to
    all subforms."
    (make-checker
     variable?
     #(println "Subexpression is invalid: " %)))

  (def fully-cheap?
    "Returns true if the supplied expression contains only cheap
    variables, false otherwise."
    (make-checker cheap?))



#+END_SRC

And a short test to that effect:

#+BEGIN_SRC clojure :tangle src/optimizer/core.clj
  (let [mixed-exp '(and (or w1 v1) v2)]
    (fact
      (conjunction (disjunction (expensive 1)
                                (cheap 1))
                   (cheap 2))
      => mixed-exp)
    (fact
      mixed-exp =not=> fully-cheap?
      mixed-exp => valid?))
#+END_SRC

Great, so now we have this form validator and some ways to build and deconstruct algebraic expressions. Next, I implemented an equality function that compares two boolean expressions, keeping the commutative law in mind.

#+BEGIN_SRC clojure :tangle src/optimizer/core.clj
  (defn fixed-point [f guess]
    (let [next (f guess)]
      (if (= guess next)
        next
        (fixed-point f next))))

  (defn eq
    "Equality for boolean expressions."
    [x y]
    (if (and (expression? x) (expression? y))
      (and (= (func x) (func y))
           (let [[lx ly] (arguments x)
                 [rx ry] (arguments y)]
             (or (and (eq lx rx) (eq ly ry))
                 (and (eq lx ry) (eq ly rx)))))
      (= x y)))

  (defn switch-or
    "returns true if the supplied binary pred returns true when passed x
    and y in either order."
    [pred x y]
    (boolean
     (or (pred x y)
         (pred y x))))

  (defn complement-law [x y]
    (and (negation? x)
         (eq (complement x) y)))

#+END_SRC

There are a few laws we can always apply that will lead to reductions.

- Involution Law: ~(not (not a)) == a~
- Identity Laws: ~(and a F) == F~, ~(and a T) == a~, ~(or a F) == a~, ~(or a T) == T~
- Idempotent Laws: ~(or a a) == a~, ~(and a a) == a~
- Complement Laws: ~(and a (not a)) == F~, ~(or a (not a)) == T~, ~(not F) == T~, ~(not T) == F~

I've also got one direction of DeMorgan's law in there.

#+BEGIN_SRC clojure :tangle src/optimizer/core.clj
  (defmacro expmatch [v & forms]
    `(let [v# ~v]
       (if-not (expression? v#)
         v#
         (match (vec v#) ~@forms))))

  (defn simplify [exp]
    (letfn [(bool-reduce [e]
              (expmatch e
                        ;; Identity Laws
                        ['and x 'F] 'F
                        ['and 'F x] 'F
                        ['or x 'T] 'T
                        ['or 'T x] 'T
                        ['not 'T] 'F
                        ['not 'F] 'T
                        ['and x 'T] x
                        ['and 'T x] x
                        ['or x 'F] x
                        ['or 'F x] x
                        ;; DeMorgan's Laws (unwrapping)
                        [(:or 'and 'or) (l :guard negation?) (r :guard negation?)]
                        (let [f (if (= (func e) 'and)
                                  conjunction
                                  disjunction)]
                          (negation
                           (f (complement l)
                              (complement r))))
                        [(:or 'and 'or) x y]
                        (let [f (func e)
                              x (simplify x)
                              y (simplify y)]
                          (cond (eq x y) x ;; Idempotent Laws
                                ;; Complement Laws
                                (switch-or complement-law x y)
                                (if (conjunction? e) 'F 'T)
                                ;; Else, sub in new, reduced arguments
                                :else (list f x y)))

                        ;; Involution Law
                        ['not (x :guard negation?)] (complement x)
                        ['not x] (negation (simplify x))
                        :else e))]
      (fixed-point bool-reduce exp)))
#+END_SRC

And some tests to show off the new simplification:

#+BEGIN_SRC clojure :tangle src/optimizer/core.clj
  (let [example-expression '(or (and (and v1 (or v2 v3)) (not w1)) F)]
    (fact
      "Reduce away the or F:"
      (simplify example-expression) => '(and (and v1 (or v2 v3)) (not w1))

      "and F == F"
      (simplify '(and (and (and v1 (or v2 v3)) (not w1)) F)) => 'F

      "No reduction..."
      (simplify '(and (or w1 v1) v2)) => '(and (or w1 v1) v2)

      "(or a a) => a"
      (simplify '(and (or w1 w1) v2)) => '(and w1 v2)))
#+END_SRC

This is where I became stuck, as you'll see. My plan for the next section was to generate a stream of permutations on the input sequence by flatMapping my little permutation generators below, map =simplify= across all and then filter by correct solutions. The next functions generate those permutations.

The uneasy realization came about that some permutations grow the size of the tree, of course, and that I'd be starting a graph walk around this space of permutations without any distance function that helped me understand how far away from a solution - a top-level =and= with only cheap variables on either side.

I walked down the road, anyway, and wrote the permutation generators:

#+BEGIN_SRC clojure :tangle src/optimizer/core.clj
  (defmacro matcher [& pairs]
    `(fn [exp#]
       (if-not (expression? exp#)
         []
         (match (vec exp#)
                ~@pairs
                :else []))))

  (def demorgan
    (matcher
     ;; DeMorgan's Laws (conjunctions)
     ['not (([_ l r] :seq) :guard conjunction?)]
     [(conjunction (negation l)
                   (negation r))]

     ['and (l :guard negation?) (r :guard negation?)]
     [(negation
       (conjunction (complement l)
                    (complement r)))]

     ;; DeMorgan's Laws (disjunctions)
     ['not (([_ l r] :seq) :guard disjunction?)]
     [(disjunction (negation l)
                   (negation r))]

     ['or (l :guard negation?) (r :guard negation?)]
     [(negation
       (disjunction (complement l)
                    (complement r)))]))

  (def associative
    (matcher
     ;; Associative Laws (conjunctions)
     ['and (([_ a b] :seq) :guard conjunction?) c]
     [(conjunction a (conjunction b c))]

     ['and a (([_ b c] :seq) :guard conjunction?)]
     [(conjunction (conjunction a b) c)]

     ;; Associative Laws (disjunctions)
     ['or (([_ a b] :seq) :guard disjunction?) c]
     [(disjunction a (disjunction b c))]

     ['or a (([_ b c] :seq) :guard disjunction?)]
     [(disjunction (disjunction a b) c)]))

  (def distributive
    (matcher
     ;; Distributive Laws
     ['and
      (([_ a b] :seq) :guard disjunction?)
      (([_ c d] :seq) :guard disjunction?)]
     (if (= a c)
       [(disjunction a (conjunction b d))]
       [])

     ['and a (([_ b c] :seq) :guard disjunction?)]
     [(disjunction (conjunction a b)
                   (conjunction a c))]

     ['or
      (([_ a b] :seq) :guard conjunction?)
      (([_ c d] :seq) :guard conjunction?)]
     (if (eq a c)
       [(conjunction a (disjunction b d))]
       [])

     ['or a (([_ b c] :seq) :guard conjunction?)]
     [(conjunction (disjunction a b)
                   (disjunction a c))]))
#+END_SRC

And then some remaining junk and tests:

#+BEGIN_SRC clojure :tangle no
  (let [cake (matcher ['and
                       (([_ a b] :seq) :guard disjunction?)
                       (([_ c d] :seq) :guard disjunction?)]
                      [(disjunction a (conjunction b d))])]
    (cake '(and (or 1 2) (or 1 3))))

  (fact
    "DeMorgan's laws:"
    (expand '(not v1)) => ['(not v1)])

  (defn commutative-expand [exp]
    (if-not (expression? exp)
      [exp]
      (match (vec exp)
             ['not a] (map negation (expand a))
             [(:or 'and 'or) ls rs]
             (let [f (func exp)]
               (apply concat
                      (for [l (expand ls)
                            r (expand rs)]
                        [(list f l r) (list f r l)]))))))

  (defn win? [exp]
    (or (cheap? exp)
        (and (expression? exp))
        (match (vec exp)
               ['and l r] (map negation (expand a))
               [(:or 'and 'or) ls rs]
               :else false)))

  (defn print-all [xs]
    (doseq [x xs] (println x)))

  (tabular
   (fact
     (?op ?x) => [?y]
     (?op ?y) => [?x])
   ?op      ?x                 ?y
   ;; DeMorgan's Laws
   demorgan '(not (and v1 v2)) '(and (not v1) (not v2))
   demorgan '(not (or v1 v2))  '(or (not v1) (not v2)))
#+END_SRC
